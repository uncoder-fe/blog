---
title: "前端性能优化"
date: "2016-09-05T15:23:03+08:00"
author: "uncoder"
tags: ["http"]
categories: ["前端相关"]
slug: ""
---

减少物理文件size，加快网络处理/响应速度，缩短页面渲染时间

<!--more-->

# 网络优化
## http2
### 使用二进制传输协议 (Binary Format)
- 二进制传输(http1.1是plain text传输)，更符合机器语言，性能好
- 体积更小，本身是01构成的二进制流，避免了http1.1一些无用空白或者低效的压缩情况
- 传输不易出错
### 多路复用
- 同域名下所有通信都在单个连接上完成，只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应, 这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。
- 同一个链接可以承载任意数量的请求/响应，并行交错，互不影响
- 降低了网络建连成本，对于弱网环境(如移动设备)收益会非常巨大
### serve push
- 在用户请求页面 HTML 时，一并把页面所需要的其他资源(如 CSS、JS 等)主动推送过来，而不必等待客户端发起对这些资源的请求
- 考虑到客户端存在文件缓存机制，服务端在推送页面时，很难判断对应客户端本地是否已存在对应文件缓存，容易造成不必要的文件传输
### 消息头压缩
- http1.1是不能进行压缩的，消息头体积较大的情况（如 Cookie 头中出现复杂长消息），性能影响非常明显
- 头部压缩可能有 90% 左右的提升，http 1.1 统计的平均响应头大小有 500 个字节左右，而 H2 的平均响应头大小只有 20 多个字节，提升比较大。
## 域名收敛
- 域名收敛，减少多个域名，使用http2的多路复用（早期 PC 浏览器，通常会限制单一域名下的并发请求连接数。为了突破这个限制，我们通常会把资源文件部署在多个不同的域名下。）
## cdn
更新频率不高、需要持久化存储的文件
### CDN 节点缓存
- 类似客户端缓存，CDN 边缘节点机房本身也会保存有一份资源缓存，当用户发起 CDN 资源请求时，会首先访问距离用户最近的 CDN 边缘节点，若 CDN 节点上存在缓存，则直接返回用户，而不必每次都请求源站。
- 可以使资源请求更快的返回，有效提升性能，同时把负载压力由源站转移到了各个 CDN 节点上，减少业务方的维护成本。
### CDN 节点缓存时间
- CDN 节点缓存时间又称回源周期，支持配置。
- 通常需要客户端强缓存时间保持一致，若不一致，则代码真实生效时间以两者缓存更久者为准。
### CDN 节点缓存强制刷新
- 若线上出现了 bug，我们想要对某资源的更新快速生效，及时止损，可以使用 CDN 节点刷新服务，触发该服务后，所有 CDN 节点缓存都会被抛弃，进行强制回源操作
## DNS解析
- 运行商 DNS 缓存、浏览器 DNS 缓存、系统 DNS 缓存开启
- link的dns-prefetch属性，尽可能早的提前发起对该域名的 dns 解析操作
## 提前建立网络连接
- 建立网络连接时，要经过 DNS 解析、TCP 握手等过程，在 https 场景下还需要进行 TLS 加密信息验证，这些都是相当耗时的操作
- link的preconnet属性，建立网络连接，在页面真正发起资源请求时，会使用已经建立的网络连接，直接跳过这些耗时建连操作
## 使用 brotli 压缩
- 比gzip压缩率高
## https优化
- HTTPS 和 HTTP 使用 TCP 协议进行传输，也就意味着必须通过三次握手建立 TCP 连接，但一个 RTT 的时间内只传输一个 syn 包是不是太浪费？能不能在 syn 包发出的同时捎上应用层的数据？其实是可以的
- HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。


* combo Handler 处理,对 js 和 css 合并压缩能减少 HTTP 请求次数(eg url??a.js,b.js)
* 利用 304 本地缓存（Last-Modify/If-Modify-Since），ETag/If-None-Match 保证每一个资源是唯一的，资源变化都会导致 ETag 变化
* 图片懒加载，滚动加载（获取视口相对位置 getBoundingClientRect），或者不加载(比如用 data-src 存储，onload 之后遍历加载替换真实的图像);
* 文件异步延迟加载（async,defer）
* 内联 css, js 置后等渲染无下载阻塞
* canvas，动画数量会增加内存占用
* position:relative;定位元素的数量

# 方案

1.  配置超长时间的本地缓存 —— 节省带宽，提高性能
2.  采用内容摘要作为缓存更新依据 —— 精确的缓存控制
3.  静态资源 CDN 部署 —— 优化网络请求
4.  更资源发布路径实现非覆盖式发布 —— 平滑升级
